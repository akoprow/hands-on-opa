[[chapter_image_p1_resources]]
iMage: part 1, Dealing with external resources
----------------------------------------------

After the announcement of iMage <<chapter_image_intro, few days ago>>
some folks are getting impatient to see some code and, well, I cannot
blame them, so without further ado let's start developing iMage.
After this post we will end up with a functional but very
bare-bone version of the app (none of the nifty animations etc.).

Remark: Because we won't yet have any descriptions of photos, it's
not yet possible to properly attribute CreativeCommon photos used
in the <<chapter_image_intro, original presentation of iMage>>,
therefore for now I'll use free photos of castles from
http://www.myfreedigitalphotos.com/architecture/castles-and-fortifications.html[MYFreeDigitalPhotos].

[icons=None, caption="Summary"]
[NOTE]
=======================
You will learn:

* How to handle external resources (such as images) in your app
* How to work with CSS.
* The basics of Opa templating.
=======================

Opa templating
~~~~~~~~~~~~~~

At the bottom of the application we want to include a small footer
attributing the images. It's just a piece of static HTML and we already
saw <<chapter_hello_web, before>> how to work with HTML. However, let's
use this opportunity to introduce the
http://opalang.org/resources/doc/index.html#template.opa.html/!/[templating mechanism of Opa].

The templating mechanism is essentially an XML interpreter. It parses
XML, checks that it conforms to the expected format and renders it
back to XHTML. By default it recognizes a subset of XHTML and renders
it as-is, making it merely a mechanism for safe inclusion of static XHTML
in Opa programs.

What makes it interesting, though, is that the templating framework is
extensible. That means one can easily extend it with interpretations for
some additional tags.

To make things more concrete: example. One way to use this extensibility
would be to accept +<markup>...</markup>+ tag which will render the content
of the tag according to some lightweight markup often found in wikis or blogs.

Since the extensions are coded as Opa callbacks, they can be application-specific
and their functionality is only limited by the developer's creativity.
We're now working on providing some interesting default extensions.

However, I will cover the topic of templating extensions in another posts.
For now we will use the simplest case of templating: inclusion of static XHTML.
For that we need to be aware of two functions:

[source, opa]
------------------------
Template.parse(engine: Template.engine, s: string) : Template.content
Template.to_xhtml(engine : Template.engine, content: Template.content) : xhtml
------------------------

The first one takes a template engine and parses a string using the
given ``engine'' (templating extensions are achieved by extending the
engine). The second one takes a template engine and a parsed content
and produces +xhtml+ from it.

We first need to import the templating module

[source, opa]
------------------------
import stdlib.web.template
------------------------

and then our function to generate the footer could look like this:

[source, opa]
------------------------
footer(txt : string) : xhtml =
  content = Template.parse(Template.default, txt)
  Template.to_xhtml(Template.default, content)
------------------------

as +Template.default+ is the default template engine. We could avoid
introducing the intermediate +content+ binding and write:

[source, opa]
------------------------
footer(txt : string) : xhtml =
  Template.to_xhtml(Template.default, Template.parse(Template.default, txt))
------------------------

It's fine for such a short expression, but with more complex ones
parsing all those parentheses easily becomes a nuisance (for us, that
is, Opa will patiently obey). The +|>+ operator comes to the rescue.
It's defined in the standard library as:

[source, opa]
------------------------
`|>`(a, f) = f(a)
------------------------

(for Haskell-aware ppl Opa's +|>+ is a variant of Haskell's
1http://stackoverflow.com/questions/940382/haskell-difference-between-dot-and-dollar-sign[+$+ operator]). +|>+ operator make it possible to nicely chain function calls.
For instance the above function could be rewritten as:

[source, opa]
------------------------
footer(txt : string) : xhtml =
  Template.parse(Template.default, txt)
  |> Template.to_xhtml(Template.default, _)
------------------------

I should add here that the underscore in the last line is a simple way
to introduce anonymous functions:

[source, opa]
------------------------
Template.to_xhtml(Template.default, _)
------------------------

is equivalent to:

[source, opa]
------------------------
arg -> Template.to_xhtml(Template.default, arg)
------------------------

[icons=None, caption="Exercise"]
[NOTE]
=======================
The +|>+ operator and the underscore construction for anonymous
functions can be a little daunting at first (especially if you
don't have much experience with functional programming). Instead
of explaining things in more detail I suggest you play with them
on your own. Trust me, there's no better way of learning than by
doing. And if things are still unclear after taking your time to
understand those concepts drop me a line in the comments and I'll
try to help.
=======================

Ok, it seems like we did not accomplish so much.
We merely turned a string with some XHTML into a proper XHTML.
In some languages indeed there would be no difference between
the two (Question: why should you be happy that this is not the
case in Opa?). Anyhow, why string? Where will that come from?
Let's see...

Embedding files
~~~~~~~~~~~~~~~

Most languages allow to bundle external resources during
deployment and then offer some form of accessing the file-system
to work with those files. In Opa external resources are
statically included during compilation time (Question:
can you think of any advantages of this approach?
Disadvantages?)

There are many ways to include external resources, the
simplest being the +@static_content+ directive, which takes
the file-name as its only argument and produces a function
that gives the content of the file (as a +string+).

Ok, now if we put a file +footer.xmlt+ with
https://github.com/akoprow/iMage/blob/83d5723c3b6993a82e0d7b4219642ca3b6c3bf6a/footer.xmlt[this content] in the current directory. And then put
together what we discussed so far and arrive at +iMage.opa+
with the following content:

[source, opa]
------------------------
include::iMage-0.opa[]
------------------------
++++
<span class="run"><A target="_blank" href="http://94.23.204.210:5004">Run</A></span>
<span class="see"><A target="_blank" href="https://github.com/akoprow/iMage/tree/iMage-0">See</A></span>
++++

(Note: click +See+ above to see the content of the repository at this step; click +Run+
to see the application running)

Then a simple:

[source, bash]
---------------------
opa iMage.opa
---------------------

will create +iMage.exe+ and running it we get a static
page with the footer (try it locally, or click +Run+ above). What
is important to realize that the produced executable (+iMage.exe+)
*will contain* +footer.xmlt+ embedded into it. That's the Opa's
philosophy:

* compile and get a single executable with no dependencies (no more forgotten files
  when you move things between servers),
* deploy the program by simply running the executable.

If you're wondering what about files that do change during execution,
read on.

Embedding directories/resources
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Let's assume that we have the images that we want to use in the +resources/imgs+
directory. Using the +@static_content+ directive we would have to mention them
one by one -- not very elegant. The +@static_resource_directory+ directive come
to our rescue. The +directory+ part of the name indicates that it will statically
include the complete content of a directory, instead of just a single file.
The +resource+ part indicates that the embedded files will be visible as
_resources_ and not just bare strings. A
http://opalang.org/resources/doc/index.html#resource.opa.html/!/[resource] is
basically anything that can be send from the server to the client, so it can
be an XHTML page, but also an image or style-sheet file.

So with the following declaration

[source, opa]
---------------------
resources_imgs = @static_resource_directory("resources/imgs")
---------------------

+resources_imgs+ is a *map* from strings (file-names) to resources corresponding
to embedded files. The http://en.wikipedia.org/wiki/Mime-type[MIME type] of the
embedded resource is determined by Opa based on the file extension.

From this resource map we can easily obtain a list of file-names:

[source, opa]
---------------------
img_list = Map.To.key_list(resources_imgs)
---------------------

and then we can produce the XHTML with those images with:

[source, opa]
---------------------
show_img(fn) = <img src={fn} />

imgs_html = List.map(show_img, img_list)
---------------------

However, this just generates a bunch of +<img>+ tags
with their +src+ attribute pointing to URLs of the shape
+resources/imgs/...+. We now need to instruct our server
to actually serve those resources at such URLs.

For that we need to use a slightly more advanced construction
of a server:

[source, opa]
---------------------
Server.one_page_bundle(title, resources, css, page)
---------------------

The first and last argument are just as for +Server.one_page_server+,
namely, page title and the function to generate the XHTML of the page.
The second argument is a list of maps of resources, so basically a list
of resources included with the +@static_resource_directory+ directive.
The third argument is a list of URLs with CSS style files for the
page.

So putting it all together we obtain the following program which will
simply display a page with all the images from the +resources/img+
directory (and a footer!).

[source, opa]
---------------------
include::iMage-1.opa[]
---------------------
++++
<span class="run"><A target="_blank" href="http://94.23.204.210:5005">Run</A></span>
<span class="see"><A target="_blank" href="https://github.com/akoprow/iMage/tree/iMage-1">See</A></span>
++++

Working with CSS
~~~~~~~~~~~~~~~~

Putting it all together
~~~~~~~~~~~~~~~~~~~~~~~

Huh, I realize that this became a rather long post. But if we put
together all that we learned so far we are going to obtain a very basic
version of
http://iMage.opalang.org/?images=http://image.opalang.org/resources/img-data-thefuturebuzz.txt[iMage]... don't worry fancy user interface and other goodies will
come in future posts :).

Notice how we changed the +show_img+ function. It still shows
an image but now on clicking it we invoke the +zoom_in+ function,
which in turn replaces the main photo with the one we clicked on
(remember, we already talked about +Dom.transform+
<<chapter_interactivity, before>>).

The remaining changes is just providing some XHTML mark-up that allows
us to write
https://github.com/akoprow/iMage/blob/ebd7bf1b78f20f94317fdc914b05d66fad26dc2e/resources/css/css.css[some CSS] to make things look acceptable. Btw. to avoid
misunderstanding: I have a basic working knowledge of CSS, but I'm by
no means no expert, neither in writing CSS, nor in designing pages.
So if something looks crappy, blame me not Opa ;). Also I'm not going
to explain the CSS that I'm using (this blog is about *developing*
in Opa and if you ask me, CSS is better left for designers).

Ok, below is the complete code of the application. It still fits on
one screen (Hint: I do have a big screen :). In the next post we're
either going to work on parsing the markup of the configuration file
with links to images to display or we'll begin pumping up the UI.
Suggestions, as always, welcome :).

[source, opa]
---------------------
include::iMage-1.opa[]
---------------------
++++
<span class="run"><A target="_blank" href="http://94.23.204.210:5006">Run</A></span>
<span class="see"><A target="_blank" href="https://github.com/akoprow/iMage/tree/iMage-2">See</A></span>
++++

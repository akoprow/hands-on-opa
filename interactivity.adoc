Interactivity, event handling
-----------------------------

[icons=None, caption="Summary"]
[NOTE]
=======================
You will learn:

* How to handle events in Opa and write interactive apps.
* How application distribution works in Opa.
=======================

Let's start with a goal for this tutorial.

[icons=None, caption="Goal"]
[NOTE]
=======================
We will write two very simple applications:

* The first one will be a page showing current time
  (updated every second).
* The second one will consist of a button. Upon pressing
  the button a message should show saying how many times
  this button was pressed *ever* (in total, by all users,
  since the creation of the application).
=======================

They may not sounds much like realistic projects but
they have exactly the characteristics I'm looking for, as:

* we will need to tackle interactivity (time-triggered changes to the page),
* as well as user interaction (response to pressing the button),
* we will need persistence on the server (to keep count of all button presses),
* while the apps are simple enough for this tutorial :).

[icons=None, caption="Exercise"]
[NOTE]
=======================
If you are a web developer write such apps in _YourFavoriteLanguage_,
before continuing with this tutorial. No, seriously, I mean it.
No worries, I'll wait.
=======================

Why is it important? I want you to be able to *really*
compare Opa with the solution you were using up till now.
And if your excuse is that you don't have time then you
should *seriously* consider Opa where solutions to both
exercises consist of around 10 LOC (as we will see)
and can be coded in 5 minutes maximum (yup, no kidding).

_(In fact, it's always a good idea to try to do those tutorials in
the tools that you are using currently (if any), to be able to compare
them better with Opa. Side note: I recently decided to learn a bit
about Ruby on Rails. I started reading
http://ruby.railstutorial.org/ruby-on-rails-tutorial-book#sec:up_and_running[this tutorial]
and, quite frankly, after reading the first chapter I'm rather horrified.
I do hope that this tutorial is outdated but it strongly suggests that,
apart form having to deal with versioning hell, anyone working with
Rails will have to deal with around 20 files to write a simple
``Hello web'' (if  you missed the previous post, in Opa it takes
<<chapter_hello_web, 1 file & 1 line>>). I mean, *seriously*?
Btw. this is not a personal attack on Ruby on Rails; this seems
to be a generally accepted situation. I'm only asking: why?
Would you ever use a language where writing ``Hello world'' would
require setting up a project with 20 files? I didn't think so...)_

Ok, we will begin with the timer app. Fasten your seat belts.
Let's rock with Opa!

Event scheduling
~~~~~~~~~~~~~~~~

Let's first see how we can display the present date in Opa. I'll try
to cover in more detail the subject of dealing with dates in some
later tutorial, but for now we will only need two functions from
the http://opalang.org/resources/doc/index.html#date.opa.html/!/value_stdlib.core.date.Date[+Date+]
module:

[source, opa]
------------------------
Date.now() : Date.date
------------------------

function which returns the current date/time and the

[source, opa]
------------------------
to_string(date : Date.date) : string
------------------------

which converts such a date to a string (using default formatting;
there are other functions which allow extensive customization, but
we will leave them for later, too).

Ok, we know how to display the date but how to update it every
second? This is where the
http://opalang.org/resources/doc/index.html#scheduler.opa.html/!/value_stdlib.core.rpc.core.Scheduler[+Scheduler+]
module comes in hand and, in particular, its +timer+ function

[source, opa]
------------------------
Scheduler.timer(delay_ms : int, callback : -> void) : void
------------------------

which calls the +callback+ function in the intervals of +delay_ms+
milliseconds.

We know how to display current time and how to perform some task
in regular time intervals. The last piece of the puzzle that
we need is a way to transform a web-page dynamically. For this
we will use the
http://opalang.org/resources/doc/index.html#dom.opa.html/!/value_stdlib.core.xhtml.Dom[+Dom+]
module and it's function

[source, opa]
------------------------
Dom.transform(l : list(Dom.transformation)) : void
------------------------

which takes a list of transformations to apply as its single
argument. One variant of a transformation comes with a special
syntax +#id <- xhtml+, which replaces the node with +id+ with
a given +xhtml+ in the DOM.

[TIP]
=======================
If you're a web developer probably you eat DOM for breakfast.
If you're an aspiring web developer then you will need to become
friends with this concept. DOM stands for Document Object Model
and is a way to represent the structure of a web page. By interacting
with this model, we effectively change the visual presentation
of the page. See http://www.w3schools.com/dom/default.asp[this page]
for more details.
=======================

Ok, we now have all the needed parts to write a web-page displaying
the current date, updated every second.

[source, opa]
------------------------
include::watch.opa[]
------------------------

So far so good. But if you read it carefully you probably have some
questions. One would be: ``Is it a server or a client date that I see
on the page?''. Or more generally: ``How is this Opa program executed?''.

This bring us to the subject of _slicing_. Slicing involves distributing
the program between the client and the server and involves:

* deciding which parts of the program should be executed where (client
  VS server),
* automatically generating JavaScript for the client parts,
* ensuring behind-the-scenes communication between the two, which let's
  the developer (that's us) concentrate on getting things done and the
  compiler (that's Opa) on providing the boring, error prone communication
  facilities.

We will not go into the details of the slicer here (interested readers
are referred to the
http://opalang.org/resources/book/index.html#_client_server_distribution[relevant part]
of the manual). Let us just make a few remarks here:

* The slicer works on the level of top-level functions; that is every
  function ends up either on the server or on the client (or on both sides)
  but will not be split between the two.
* Some primitives can exist only on the server (like data-base
  manipulation) and some only on the client (like Dom manipulation).
* There exist annotations (+@server+, +@client+, +@both+ and +@both_implem+;
  details in the
  http://opalang.org/resources/book/index.html#_client_server_distribution[manual])
  to instruct the slicer about the required location for any function.
* There also exist annotations for visibility (+@public+, +@server_private+),
  i.e. to differentiate between server functions that are visible to the
  client and those that are not (for security reasons).

This is where the magic starts to happen, so let's just stop for a moment to
contemplate the implications of this Opa feature. It means we write code in one
language, pretty much as we would do developing a desktop application, but here
as a result we obtain a fully distributed application with all the communication
glue provided behind the scenes by Opa.

This also means that moving some app functionality from the client to the
server or vice-versa is as simple as adding a small annotation. So one can easily
prototype without thinking much about what goes where and only later on add
few annotations to optimize the amount of client-server communication. Ain't
that cool?

Few minor remarks concerning our timer program. Suppose that we moved the
above +show_time()+ function to be local in the +page()+ function, as here:

[source, opa]
------------------------
include::watch2.opa[]
------------------------

Does that change anything? Well, it's still a perfectly valid Opa program, but
note what I said earlier that slicing is done on a per-function basis. Where
will the +page()+ function go? It's used by the server to prepare the page to
serve and hence must be on the server and therefore so will be its local +show_time()+
function. That means that this variant of our program... yes, will display
server time and will call the server every second. Therefore to get efficiently
running applications one needs to think a bit about the client/server separation
and proper decomposition of the program into functions (don't worry, though,
it's easy enough to change things if you don't get them perfect at first).

Ok, this is growing into a monsterous post so let me stop here and I will continue
in the next post (coming tomorrow, or in 2 days tops). Happy coding!

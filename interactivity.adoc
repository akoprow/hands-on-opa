Interactivity, event handling
-----------------------------

[icons=None, caption="Summary"]
[NOTE]
=======================
You will learn:

* How to handle events in Opa and write interactive apps.
* How application distribution works in Opa.
=======================

Let's start with a goal for this tutorial.

[icons=None, caption="Goal"]
[NOTE]
=======================
Write a web page showing: current time (updated every second)
and a button. Upon pressing the button a message should show
saying how many times this button was pressed *ever* (in total,
by all users, since the creation of the application).
=======================

I know this ``project'' sounds rather artificial, but it
has exactly the characteristics I'm looking for, as:

* it involves interactivity (time-triggered changes to the page),
* it involves user interaction (response to pressing the button),
* it involves persistance on the server (to keep count of all button presses),
* while still being simple enough for this tutorial :).

[icons=None, caption="Exercise"]
[NOTE]
=======================
If you are a web developer write such an app in _YourFavoriteLanguage_,
before continuing with this tutorioal. No, seriously, I mean it.
No worries, I'll wait.
=======================

Why is it important? I want you to be able to *really*
compare Opa with the solution you were using up till now.
And if your excuse is that you don't have time then you
should *seriously* consider Opa where the complete solution
looks like this:

[source, opa]
------------------------
include::interactivity.opa[]
------------------------

and it took me 4 minutes to write it (yup, no kidding).

_(In fact, it's always a good idea to try to do those tutorials in
the tools that you are using currently (if any), to be able to compare
them better with Opa. Side note: I recently decided to learn a bit
about Ruby on Rails. I started reading
http://ruby.railstutorial.org/ruby-on-rails-tutorial-book#sec:up_and_running[this tutorial]
and, quite frankly, after reading the first chapter I'm rather horrified.
I do hope that this tutorial is outdated but it strongly suggests that,
apart form having to deal with versioning hell, anyone working with
Rails will have to deal with around 20 files to write a simple
``Hello web'' (if  you missed the previous post, in Opa it takes
<<chapter_hello_web, 1 file & 1 line>>). I mean, *seriously*?
Btw. this is not a personal attack on Ruby on Rails; this seems
to be a generally accepted situation. I'm only asking: why?
Would you ever use a language where writing ``Hello world'' would
require setting up a project with 20 files? I didn't think so...)_

As you could see the program we will arrive at is rather short but
I'll now break it down and go over all its parts in detail.

Ok, fasten your seat belts. Let's rock with Opa.

Event scheduling
~~~~~~~~~~~~~~~~

Let's first see how we can display the present date in Opa. I'll try
to cover in more detail the subject of dealing with dates in some
later tutorial, but for now we will only need two functions from
the http://opalang.org/resources/doc/index.html#date.opa.html/!/value_stdlib.core.date.Date[+Date+]
module:

[source, opa]
------------------------
Date.now() : Date.date
------------------------

function which returns the current date/time and the

[source, opa]
------------------------
to_string(date : Date.date) : string
------------------------

which converts such a date to a string (using default formatting;
there are other functions which allow extensive customization, but
we will leave them for later, too).

Ok, we know how to display the date but how to update it every
second? This is where the
http://opalang.org/resources/doc/index.html#scheduler.opa.html/!/value_stdlib.core.rpc.core.Scheduler[+Scheduler+]
module comes in hand and, in particular, its +timer+ function

[source, opa]
------------------------
Scheduler.timer(delay_ms : int, callback : -> void) : void
------------------------

which calls the +callback+ function in the intervals of +delay_ms+
milliseconds.

We know how to display current time and how to perform some task
in regular time intervals. The last piece of the puzzle that
we need is a way to transform a web-page dynamically. For this
we will use the
http://opalang.org/resources/doc/index.html#dom.opa.html/!/value_stdlib.core.xhtml.Dom[+Dom+]
module and it's function

[source, opa]
------------------------
Dom.transform(l : list(Dom.transformation)) : void
------------------------

which takes a list of transformations to apply as its single
argument. One variant of a transformation comes with a special
syntax +#id <- xhtml+, which replaces the node with +id+ with
a given +xhtml+ in the DOM.

[TIP]
=======================
If you're a web developer probably you eat DOM for breakfast.
If you're an aspiring web developer then you will need to become
friends with this concept. DOM stands for Document Object Model
and is a way to represent the structure of a web page. By interacting
with this model, we effectively change the visual presentation
of the page. See http://www.w3schools.com/dom/default.asp[this page]
for more details.
=======================

Ok, we now have all the needed parts to write a web-page displaying
the current date, updated every second.

[source, opa]
------------------------
include::watch.opa[]
------------------------

So far so good. But if you read it carefully you probably have some
questions. One would be: ``Is it a server or a client date that I see
on the page?''. Or more generally: ``How is this Opa program executed?''.

This bring us to the subject of _slicing_. Slicing involves distributing
the program between the client and the server and involves:

* deciding which parts of the program should be executed where (client
  VS server),
* automatically generating Javascript for the client parts,
* ensuring behind-the-scenes communication between the two, which let's
  the devoper (that's us) concentrate on getting things done and the
  compiler (that's Opa) on providing the boring, error prone communication
  facilities.

We will not go into the details of the slicer here (interested readers
are referred to the
http://opalang.org/resources/book/index.html#_client_server_distribution[relevant part]
of the manual). Let us just make a few remarks here:

* The slicer works on the level of top-level functions; that is every
  function ends up either on the server or on the client (or on both sides)
  but will not be split between the two.
* Some primitives can exist only on the server (like data-base
  manipulation) and some only on the client (like Dom manipulation).
* There exist annotations (+@server+, +@client+, +@both+ and +@both_implem+;
  details in the
  http://opalang.org/resources/book/index.html#_client_server_distribution[manual])
  to instruct the slicer about the required location for any function.
* There also exist annotations for visibility (+@public+, +@server_private+),
  i.e. to differentiate between server functions that are visible to the
  client and those that are not (for security reasons).
